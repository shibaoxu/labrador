import com.bmuschko.gradle.docker.tasks.DockerInfo
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.extras.DockerWaitHealthyContainer
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import com.bmuschko.gradle.docker.tasks.network.DockerExistingNetwork
import com.github.dockerjava.api.DockerClient

buildscript {
    repositories {
        gradlePluginPortal()
        maven {
            url "http://maven.aliyun.com/nexus/content/groups/public/"
        }
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenCentral()
    }
    dependencies{
        classpath 'com.bmuschko:gradle-docker-plugin:4.6.2'
    }
}

/****************************** 配置Root应用 ******************************
 * Root应用中包含用于整个工程的任务，包括:
 * dockerInfo: 等同于运行 docker info
 * buildBootBaseImage: 创建整个工程的父镜像
 * pushBaseImage: 把父镜像推送到镜像仓库
 * setupNetwork: 创建docker网络
 * setup: 创建docker网络，并创建spring boot基础镜像
 *************************************************************************/
apply plugin: com.bmuschko.gradle.docker.DockerRemoteApiPlugin

docker {
    registryCredentials {
        url = 'https://index.docker.io/v1/'
        username = dockerRegistryUsername
        password = dockerRegistryPassword
        email = dockerRegistryEmail
    }
}

task dockerInfo(type: DockerInfo){}

task removeBootBaseImage(type: DockerRemoveImage){
    imageId = dockerBootBaseImage
    onError{exception ->
        if (exception.message.contains("No such image: ${dockerBootBaseImage}")){
            logger.quiet("要删除的镜像:${dockerBootBaseImage}不存在")
        }else{
            throw exception
        }
    }
}
task setupBootBaseImage(type: DockerBuildImage){
    dependsOn(removeBootBaseImage)
    inputDir = new File(rootProject.projectDir, 'docker/baseimage')
    tags.add("${dockerBootBaseImage}")
}

task pushBaseImage(type: DockerPushImage){
    imageName = "${dockerBootBaseImage}"
}

task setupNetwork(type: SetupNetwork){
    networkId = 'labrador'
}

task setup(){
    dependsOn setupBootBaseImage, setupNetwork
}

task hello{
    doFirst {
        println 'hello'
    }
//    println project.emptyString.isAllWhitespace()
}
/****************************** 配置Boot应用 ******************************/
configure(bootApps.collect({project(it)})) {
    apply plugin: com.bmuschko.gradle.docker.DockerSpringBootApplicationPlugin
    docker {
        registryCredentials {
            url = 'https://index.docker.io/v1/'
            username = dockerRegistryUsername
            password = dockerRegistryPassword
            email = dockerRegistryEmail
        }
        springBootApplication {
            baseImage = "${dockerBootBaseImage}"
            tag = "$dockerRegistry/$project.name:$project.version".toString()
            ports = getAppPorts(project)
        }
    }

    // 删除已经存在的具有同样标签的镜像，用于防止产生无用的镜像
    task removeAppImage(type: DockerRemoveImage){
        description = '删除本地和将要构建的镜像tag相同的镜像'
        imageId = "$dockerRegistry/$project.name:$project.version".toString()
        onError { exception ->
            if (!exception.message.contains('No such image')){
                throw exception
            } else {
                logger.quiet("镜像:${imageId.get()}不存在")
            }
        }
        onComplete{
            logger.quiet("成功删除镜像${imageId.get()}")
        }
    }
    // 构建镜像之前先删除旧的镜像
    dockerBuildImage.dependsOn(removeAppImage)
    dockerBuildImage.dependsOn(bootJar)

    /**
     * 由于要在容器的运行命令中增加-Dspring.profiles.active参数，所以重置了默认的command
     * 如果在运行gradle命令时没有指定-Dspring.profiles.active的值，则默认是prod
     */
    dockerCreateDockerfile.entryPoint("java")
    dockerCreateDockerfile.defaultCommand("-jar",
            "-Dspring.profiles.active=${project.profile}",
            "/app/${project.name}-${project.version}.jar")

    // 配置living状态检查指令
//    dockerCreateDockerfile.instruction("HEALTHCHECK --interval=10s --timeout=3s --start-period=10s " +
//            "CMD curl -f --silent http://localhost:8080/actuator/health || exit 1")
    dockerCreateDockerfile.instruction("HEALTHCHECK CMD curl -f --silent http://localhost:8080/actuator/health || exit 1")
//    dockerCreateDockerfile.instruction("HEALTHCHECK --interval=1m --start-period=5m CMD curl -f --silent http://localhost:8080/actuator/health || exit 1")

    /**
     * 创建应用容器
     * 绑定的端口默认为8080:8080, 可以在子项目的build.gradle中进行修改
     */
    task createAppContainer(type: DockerCreateContainer) {
        description = '创建应用容器'
        dependsOn dockerBuildImage
        targetImageId dockerBuildImage.getImageId()
        portBindings = getAppBindPorts(project)

        containerName = "${project.name}".toString()
        network = "${dockerNetwork}".toString()
//        autoRemove = true
        if(project.profile == 'local' && !project.name.equals('eurekaservice')) {
            cmd = [
                    "-jar",
                    "-Dspring.profiles.active=${project.profile}".toString(),
                    "-Deureka.client.service-url.defaultZone=http://eurekaservice:${getAppPorts(project(':eurekaservice'))[0]}/eureka/".toString(),
                    "/app/${project.name}-${project.version}.jar".toString()
            ]
        }
    }

    /**
     * 启动应用容器
     */
    task startAppContainer(type: DockerStartContainer) {
        description = '启动应用容器'
        dependsOn createAppContainer
        targetContainerId createAppContainer.getContainerId()
    }

    /**
     * 检查容器的living状态
     * 如果要对awaitStatusTimeout和checkInterval进行特殊配置，可在子项目的build.gradle中修改
     */
    task healthCheck(type: DockerWaitHealthyContainer){
        description = '对容器进行健康检查'
        dependsOn startAppContainer
        containerId = startAppContainer.getContainerId()
        awaitStatusTimeout = 300
        checkInterval = 500
    }

    /**
     * 停止应用容器
     */
    task stopAppContainer(type: DockerStopContainer) {
        description = '停止应用容器'
        targetContainerId createAppContainer.getContainerId()
    }

}

def getAppPorts(project){
    def appPort = "${project.name}AppPorts"
    def defaultAppPort = 'defaultAppPorts'

    if (project.hasProperty(appPort)){
        if (validateAppPorts(project[appPort])){
            return project[appPort].split(",").collect{it.trim().toInteger()}
        }else{
            throw new GradleException("${appPort}配置错误，端口号只能是整数。")
        }
    }else{
        if (project.hasProperty(defaultAppPort)){
            if (validateAppPorts(project[defaultAppPort])){
                logger.info("没有配置${appPort},使用默认的appPort配置${project[defaultAppPort]}")
                return project[defaultAppPort].split(",").collect{it.trim().toInteger()}
            }else{
                throw new GradleException("${defaultAppPort}配置错误，端口号只能是整数。")
            }
        }else{
            logger.info('应用没有配置应用程序端口,使用默认端口8080')
            return [8080]
        }
    }
}

def validateAppPorts(ports){
    return !ports.isAllWhitespace() && ports.split(",").findAll{!it.isInteger()}.isEmpty()
}

def validateBindPorts(bindPorts){
    return bindPorts.split(",").findAll {
        !it.split(":").findAll{!it.trim().isInteger()}.isEmpty()
    }.isEmpty()
}
def getAppBindPorts(project){
    def bindPort = "${project.name}BindPorts"
    if (project.hasProperty(bindPort)){
        if (validateBindPorts(project[bindPort])){
            return project[bindPort].split(",").collect{it}
        }else{
            throw new GradleException("${bindPort}配置错误，绑定端口配置格式为8080:8080,9090:9090.")
        }
    }
    return []
}
/**
 * 检查docker网络是否已经存在，如果已经存在则先删除已有网络，然后创建新网络。
 * 如果不存在，则直接创建新网络
 */
class SetupNetwork extends DockerExistingNetwork{
    void runRemoteCommand(DockerClient dockerClient) {
        logger.quiet "Set up network: '${networkId.get()}'."
        def isExisted = false
        try{
            dockerClient.inspectNetworkCmd().withNetworkId(networkId.get()).exec()
            isExisted = true
            logger.quiet("${networkId.get()}已经存在")
        } catch (exception){
            println 'network not existed.'
        }

        if (isExisted){
            logger.quiet("删除网络:${networkId.get()}")
            dockerClient.removeNetworkCmd(networkId.get()).exec()
        }

        logger.quiet("创建网络: ${networkId.get()}")
        dockerClient.createNetworkCmd().withName(networkId.get()).exec()

        if (nextHandler) {
            nextHandler.execute(network)
        }
    }
}